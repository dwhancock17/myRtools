---
title: "Untitled"
format: html
---

## Step 2: Update DESCRIPTION File

After the package is created, manually edit the `DESCRIPTION` file with this content:

```
Package: myRtools
Title: Personal R Utility Functions
Version: 0.1.0
Authors@R: 
    person("David", "Hancock", , "your.email@example.com", role = c("aut", "cre"))
Description: A collection of personal utility functions for R programming,
    including package management, data summaries, and other workflow helpers.
License: MIT + file LICENSE
Encoding: UTF-8
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.2.3
Imports: 
    utils
Suggests: 
    testthat (>= 3.0.0)
Config/testthat/edition: 3
URL: https://github.com/dwhancock17/myRtools
BugReports: https://github.com/dwhancock17/myRtools/issues
```

## Step 3: Create Main Function File

Run this to create the main function file:

```{r create-function-file}
#| eval: false

# Create the main function file
usethis::use_r("manage_packages")

usethis::use_r("utils-pipe")

usethis::use_r("utils-global-variables")
# This will open R/manage_packages.R
# Copy and paste the function code below into that file:
```

Copy this code into the `R/manage_packages.R` file that opens:

```{r function-code}
#| eval: false
#| code-fold: true

#' Manage Package Installation and Loading
#'
#' Automatically checks for missing packages, installs them if needed, and loads all requested packages.
#' Provides detailed feedback on the installation and loading process.
#'
#' @param packages Character vector of package names to install and load
#' @param quiet Logical, if TRUE suppresses installation messages (default: FALSE)
#' @return Invisible list containing installation and loading status details
#' @export
#' @examples
#' \dontrun{
#' # Basic usage
#' manage_packages(c("dplyr", "ggplot2"))
#' 
#' # Quiet mode
#' manage_packages(c("gt", "gtsummary"), quiet = TRUE)
#' 
#' # Capture status for programmatic use
#' status <- manage_packages(c("tidyverse", "data.table"))
#' if(status$success_rate < 1) {
#'   warning("Some packages failed to load")
#' }
#' }
manage_packages <- function(packages, quiet = FALSE) {
  # Initialize status tracking
  already_installed <- character(0)
  newly_installed <- character(0)
  failed_installs <- character(0)
  load_failures <- character(0)
  
  for(pkg in packages) {
    # Check if package is already installed
    if(pkg %in% utils::installed.packages()[,"Package"]) {
      already_installed <- c(already_installed, pkg)
    } else {
      # Try to install the package
      if(!quiet) cat("Installing package:", pkg, "...\n")
      
      tryCatch({
        utils::install.packages(pkg, repos = "https://cran.rstudio.com/", quiet = quiet)
        newly_installed <- c(newly_installed, pkg)
      }, error = function(e) {
        failed_installs <<- c(failed_installs, pkg)
        if(!quiet) cat("Failed to install:", pkg, "\n")
      })
    }
  }
  
  # Now try to load all packages
  for(pkg in packages) {
    if(!pkg %in% failed_installs) {
      tryCatch({
        suppressPackageStartupMessages(
          library(pkg, character.only = TRUE, quietly = quiet)
        )
      }, error = function(e) {
        load_failures <<- c(load_failures, pkg)
      })
    }
  }
  
  # Generate status report
  total_packages <- length(packages)
  successful_loads <- total_packages - length(failed_installs) - length(load_failures)
  
  if(!quiet) {
    cat("\n=== PACKAGE MANAGEMENT SUMMARY ===\n")
    cat("Total packages requested:", total_packages, "\n")
    
    if(length(already_installed) > 0) {
      cat("Already installed:", paste(already_installed, collapse = ", "), "\n")
    }
    
    if(length(newly_installed) > 0) {
      cat("Newly installed:", paste(newly_installed, collapse = ", "), "\n")
    }
    
    if(length(failed_installs) > 0) {
      cat("Failed to install:", paste(failed_installs, collapse = ", "), "\n")
    }
    
    if(length(load_failures) > 0) {
      cat("Failed to load:", paste(load_failures, collapse = ", "), "\n")
    }
    
    cat("Successfully loaded:", successful_loads, "out of", total_packages, "packages\n")
    
    if(successful_loads == total_packages) {
      cat("✓ All packages ready for use!\n")
    } else {
      cat("⚠ Some packages may not be available\n")
    }
    cat("=======================================\n\n")
  }
  
  # Return status invisibly for programmatic use
  invisible(list(
    total = total_packages,
    already_installed = already_installed,
    newly_installed = newly_installed,
    failed_installs = failed_installs,
    load_failures = load_failures,
    success_rate = successful_loads / total_packages
  ))
}

#' Quick Data Summary
#'
#' Provides a quick overview of a data frame including dimensions and structure
#'
#' @param data A data frame to summarize
#' @param show_str Logical, whether to show str() output (default: TRUE)
#' @return Invisible NULL, prints summary to console
#' @export
#' @examples
#' \dontrun{
#' quick_summary(mtcars)
#' quick_summary(iris, show_str = FALSE)
#' }
quick_summary <- function(data, show_str = TRUE) {
  cat("=== DATA SUMMARY ===\n")
  cat("Rows:", nrow(data), "| Columns:", ncol(data), "\n")
  cat("Missing values:", sum(is.na(data)), "\n")
  
  if(show_str) {
    cat("\nStructure:\n")
    utils::str(data)
  }
  
  cat("====================\n")
  invisible(NULL)
}

#' Descriptive Table with Univariate Odds Ratios
#'
#' Creates a publication-ready table combining descriptive statistics and
#' univariate odds ratios for a binary outcome. Automatically handles both
#' categorical and continuous predictors. Optionally performs univariate
#' regression on a random subsample for large datasets.
#'
#' @param data A data frame
#' @param outcome A binary outcome variable (factor preferred; first level = reference)
#' @param predictors Character vector of predictor variable names
#' @param cat_stat Statistic for categorical variables (default: "n (%)")
#' @param cont_stat Statistic for continuous variables (default: median [IQR])
#' @param family Model family (default: binomial())
#' @param or_sample_n Optional integer; if set, univariate ORs are estimated
#'   on a simple random subsample of this size
#' @param seed Optional random seed for reproducibility
#'
#' @return A gtsummary table object
#' @export
make_desc_or_table <- function(
  data,
  outcome,
  predictors,
  cat_stat = "{n} ({p}%)",
  cont_stat = "{median} ({p25}, {p75})",
  family = binomial(),
  or_sample_n = NULL,
  seed = NULL
) {

  n_total <- nrow(data)

  # -----------------------------
  # Descriptives (full data)
  # -----------------------------
  tbl_desc <- data %>%
    dplyr::select({{ outcome }}, dplyr::all_of(predictors)) %>%
    gtsummary::tbl_summary(
      by = {{ outcome }},
      statistic = list(
        gtsummary::all_categorical() ~ cat_stat,
        gtsummary::all_continuous()  ~ cont_stat
      ),
      missing = "no"
    ) %>%
    gtsummary::add_overall(last = FALSE) %>%
    gtsummary::modify_header(
      label ~ "**Characteristic**",
      gtsummary::all_stat_cols() ~ "**{level}**"
    )

  # -----------------------------
  # Prepare data for ORs
  # -----------------------------
  or_data <- data

  if (!is.null(or_sample_n) && n_total > or_sample_n) {

    if (!is.null(seed)) set.seed(seed)

    or_data <- data %>%
      dplyr::slice_sample(n = or_sample_n)

    message(
      "Univariate ORs estimated on random subsample (n = ",
      format(or_sample_n, big.mark = ","),
      " of ",
      format(n_total, big.mark = ","),
      ")."
    )
  }

  # -----------------------------
  # Univariate ORs
  # -----------------------------
  tbl_or <- or_data %>%
    dplyr::select({{ outcome }}, dplyr::all_of(predictors)) %>%
    gtsummary::tbl_uvregression(
      y = {{ outcome }},
      method = glm,
      method.args = list(family = family),
      exponentiate = TRUE
    ) %>%
    gtsummary::modify_header(
      estimate ~ "**Odds Ratio (95% CI)**"
    )

  # -----------------------------
  # Merge tables
  # -----------------------------
  gtsummary::tbl_merge(
    tbls = list(tbl_desc, tbl_or),
    tab_spanner = c(
      "**Descriptive Statistics**",
      "**Univariate Odds Ratios**"
    )
  )
}

#' Save a gtsummary Table to File
#'
#' Saves a gtsummary table to HTML, PDF, or Word format.
#'
#' @param tbl A gtsummary table object
#' @param filename Output filename (.html, .pdf, or .docx)
#'
#' @return Invisible NULL
#' @export
#'
#' @examples
#' \dontrun{
#' tbl <- make_desc_or_table(dat_filter, refusal, vars)
#' save_gtsummary(tbl, "Table1.html")
#' save_gtsummary(tbl, "Table1.docx")
#' }
save_gtsummary <- function(tbl, filename) {

  if (!inherits(tbl, "gtsummary")) {
    stop("tbl must be a gtsummary object")
  }

  if (grepl("\\.docx$", filename, ignore.case = TRUE)) {

    tbl %>%
      gtsummary::as_flex_table() %>%
      flextable::save_as_docx(path = filename)

  } else if (grepl("\\.(html|pdf)$", filename, ignore.case = TRUE)) {

    tbl %>%
      gtsummary::as_gt() %>%
      gt::gtsave(filename)

  } else {
    stop("Unsupported file type. Use .html, .pdf, or .docx")
  }

  invisible(NULL)
}

#' Compare Univariate Odds Ratios Across Two Random Subsamples
#'
#' Fits univariate logistic regression models on two independent random
#' subsamples and returns odds ratios for comparison.
#'
#' @param data A data frame
#' @param outcome A binary outcome variable
#' @param predictors Character vector of predictor variable names
#' @param sample_n Size of each random subsample
#' @param seed Optional base seed; second sample uses seed + 1
#' @param family Model family (default: binomial())
#'
#' @return A tibble with odds ratios from both subsamples
#' @export
compare_uv_or_subsamples <- function(
  data,
  outcome,
  predictors,
  sample_n,
  seed = NULL,
  family = binomial()
) {

  if (sample_n >= nrow(data)) {
    stop("sample_n must be smaller than the number of rows in data")
  }

  if (!is.null(seed)) set.seed(seed)
  dat1 <- dplyr::slice_sample(data, n = sample_n)

  if (!is.null(seed)) set.seed(seed + 1)
  dat2 <- dplyr::slice_sample(data, n = sample_n)

  fit_models <- function(dat) {
    gtsummary::tbl_uvregression(
      data = dat %>% dplyr::select({{ outcome }}, dplyr::all_of(predictors)),
      y = {{ outcome }},
      method = glm,
      method.args = list(family = family),
      exponentiate = TRUE
    )$table_body %>%
      dplyr::filter(!reference_row) %>%
      dplyr::select(
        variable,
        label,
        estimate,
        conf.low,
        conf.high
      )
  }

  res1 <- fit_models(dat1) %>%
    dplyr::rename_with(~ paste0(.x, "_s1"), -c(variable, label))

  res2 <- fit_models(dat2) %>%
    dplyr::rename_with(~ paste0(.x, "_s2"), -c(variable, label))

  dplyr::left_join(res1, res2, by = c("variable", "label"))
}

```

## Step 4: Set Up Package Dependencies and License

```{r setup-dependencies}
#| eval: false

# Add package dependencies
usethis::use_package("utils", type = "Imports")
usethis::use_package("dplyr")
usethis::use_package("gtsummary")
usethis::use_package("stats")
usethis::use_package("gt")
usethis::use_package("flextable")
usethis::use_package("magrittr")

# Add MIT license
usethis::use_mit_license()

# Set up testing framework
usethis::use_testthat()
```

## Step 5: Create Tests

```{r create-tests}
#| eval: false

# Create test file
usethis::use_test("manage_packages")

# This will open tests/testthat/test-manage_packages.R
# Copy the test code below into that file:
```

Copy this into the test file that opens:

```{r test-code}
#| eval: false

test_that("manage_packages works with valid packages", {
  # Test with a package that should always be available
  result <- manage_packages("base", quiet = TRUE)
  
  expect_type(result, "list")
  expect_equal(result$total, 1)
  expect_equal(result$success_rate, 1)
  expect_length(result$failed_installs, 0)
  expect_length(result$load_failures, 0)
})

test_that("manage_packages handles invalid packages gracefully", {
  # Test with a non-existent package
  result <- manage_packages("nonexistentpackage12345", quiet = TRUE)
  
  expect_type(result, "list")
  expect_equal(result$total, 1)
  expect_equal(result$success_rate, 0)
  expect_length(result$failed_installs, 1)
  expect_equal(result$failed_installs, "nonexistentpackage12345")
})

test_that("quick_summary works with data frames", {
  expect_output(quick_summary(mtcars, show_str = FALSE), "Rows: 32")
  expect_output(quick_summary(iris, show_str = FALSE), "Columns: 5")
})

test_that("make_desc_or_table returns gtsummary object", {

  dat <- data.frame(
    refusal = factor(c("Transported", "Refused Care", "Transported")),
    age = c(70, 82, 77),
    gender = factor(c("Male", "Female", "Male"))
  )

  tbl <- make_desc_or_table(
    data = dat,
    outcome = refusal,
    predictors = c("age", "gender")
  )

  expect_s3_class(tbl, "gtsummary")
})

test_that("save_gtsummary rejects non-gtsummary input", {
  expect_error(
    save_gtsummary(mtcars, "test.html"),
    "gtsummary"
  )
})
```

## Step 6: Create README

```{r create-readme}
#| eval: false

# Create README file
usethis::use_readme_md()

# This will open README.md - replace its contents with the text below:
```

Copy this into the README.md file that opens:

```markdown
# myRtools

Personal R utility functions for streamlined data analysis workflows.

## Installation

You can install myRtools from GitHub:

```r
# Install devtools if you haven't already
install.packages("devtools")

# Install myRtools
devtools::install_github("dwhancock17/myRtools")
```

## Usage

### Package Management

Easily install and load multiple packages:

```r
library(myRtools)

# Install and load packages
manage_packages(c("dplyr", "ggplot2", "gt"))

# Quiet mode
manage_packages(c("tidyverse", "data.table"), quiet = TRUE)
```

### Quick Data Summary

Get a fast overview of your data:

```r
# Quick summary
quick_summary(mtcars)

# Without structure details
quick_summary(iris, show_str = FALSE)
```

### Descriptive Tables with Odds Ratios

Create a combined descriptive and univariate odds ratio table:

```r
vars <- c("age_cat", "gender", "race", "time_to_scene", "business_hours")

make_desc_or_table(
  data = data,          # ~10M rows
  outcome = DV,
  predictors = IVs,
  or_sample_n = 1e6,          # ORs on 1M rows
  seed = 202402
)

```

### Saving gtsummary Tables

Save a gtsummary table produced by make_desc_or_table() (or any other gtsummary workflow) to common manuscript-ready formats with a single function call.

Supported formats include HTML, Word (.docx), and PDF.

```r
# Create the table
vars <- c("age_cat", "gender", "race", "time_to_scene", "business_hours")

table1 <- make_desc_or_table(
  data = dat_filter,
  outcome = refusal,
  predictors = vars
)

# View in RStudio
table1

# Save for manuscripts or reports
save_gtsummary(table1, "Table1.html")
save_gtsummary(table1, "Table1.docx")
```

### Sensitivity check of stability of ORs in random subsamples

This function is not for tables — it’s for diagnostics and reassurance.

What it does

Draws two independent random subsamples

Fits univariate ORs in each

Returns tidy results so you can:

eyeball consistency

save as a supplement

reassure reviewers (or yourself)

```r
# Sample two independent random samples and compare 
or_compare <- compare_uv_or_subsamples(
  data = dat_filter,
  outcome = refusal,
  predictors = vars,
  sample_n = 500000,
  seed = 123
)

or_compare
```


## Functions

- `manage_packages()`: Automatically install missing packages and load all requested packages
- `quick_summary()`: Provide quick overview of data frame dimensions and structure
- `make_desc_or_table()`: Create a combined descriptive and univariate odds ratio table
- `save_gtsummary()`: Save gtsummary tables as HTML, .docx, or PDF
- `compare_uv_or_subsample()`: Compare univariate independent random subsamples for stability

## License

MIT License
```
```

## Step 7: Build and Document Package

```{r build-package}
#| eval: false

# Generate documentation from roxygen comments
devtools::document()

# Check package for issues
devtools::check()

# Install package locally to test
devtools::install()
```

## Step 8: Set Up GitHub Repository

```{r setup-github}
#| eval: false

# Initialize git repository
usethis::use_git()

# Create GitHub repository and push
# This will open a browser window to create the repo
usethis::use_github()

# Optional: Add GitHub Actions for automated checking
usethis::use_github_action_check_standard()
```

## Step 9: Test Installation from GitHub

After pushing to GitHub, test installation:

```{r test-github-install}
#| eval: false

# Remove local version to test GitHub installation
remove.packages("myRtools")

# Install from GitHub
devtools::install_github("dwhancock17/myRtools")

# Test that it works
library(myRtools)
manage_packages(c("readr", "stringr"))
```

## Usage on Other Computers

On any other computer, just run:

```{r usage-other-computers}
#| eval: false

# One-time installation
devtools::install_github("dwhancock17/myRtools")

# Then use in any script or Quarto document
library(myRtools)
manage_packages(c("tidyverse", "gt", "gtsummary", "data.table"))
```

## Adding More Functions Later

To add new functions to your package:

```{r add-functions}
#| eval: false

# Create new function file
usethis::use_r("new_function_name")

# After adding functions, always:
devtools::document()  # Update documentation
devtools::check()     # Check for issues
devtools::install()   # Reinstall locally

# Commit and push to GitHub
# Users can update with: devtools::install_github("dwhancock17/myRtools")
```

## Summary

Once set up, your workflow becomes:

1. **One-time setup**: Run through Steps 1-8 above
2. **On any computer**: `devtools::install_github("dwhancock17/myRtools")`
3. **In any script**: `library(myRtools); manage_packages(c("your", "packages"))`

Your functions are now available anywhere you have R and internet access!
